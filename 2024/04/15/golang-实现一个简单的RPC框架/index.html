<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/Bopop-logo.png">
  <link rel="icon" type="image/png" href="/img/Bopop-logo.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="This v blog">
  <meta name="author" content="BoDen">
  <meta name="keywords" content="Bopop,blog,博客,PHP,Python,Golang">
  <title>golang 实现一个简单的RPC框架 - Bopop</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 5.0.2"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Bopop</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/pexels.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                golang 实现一个简单的RPC框架
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2024-04-15 10:25">
      2024年4月15日 上午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      60
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h2 id="🔌-golang-实现一个简单的RPC框架"><a class="header-anchor" href="#🔌-golang-实现一个简单的RPC框架"></a>🔌 golang 实现一个简单的RPC框架</h2>
<p>远程过程调用(RPC)是分布式系统中不可或缺的通信方式，它允许一个程序调用另一个地址空间（通常是网络上的另一台机器）的过程或函数，就像调用本地函数一样。本文将带你从零开始实现一个简单但功能完整的Go语言RPC框架，帮助你深入理解RPC的工作原理。</p>
<h3 id="📚-RPC基础概念"><a class="header-anchor" href="#📚-RPC基础概念"></a>📚 RPC基础概念</h3>
<p>在开始实现之前，让我们先了解RPC的基本概念和工作流程：</p>
<ol>
<li><strong>客户端存根(Client Stub)</strong>：在客户端封装远程调用的细节，使远程调用看起来像本地调用</li>
<li><strong>服务端存根(Server Stub)</strong>：接收客户端请求，解码参数，调用本地服务，然后编码结果返回</li>
<li><strong>序列化/反序列化</strong>：将函数调用的参数和返回值在网络上传输</li>
<li><strong>网络传输</strong>：在客户端和服务端之间传输序列化后的数据</li>
</ol>
<p>一个典型的RPC调用流程如下：</p>
<pre><code class="hljs clean">客户端 -&gt; 客户端存根 -&gt; 序列化 -&gt; 网络传输 -&gt; 服务端存根 -&gt; 反序列化 -&gt; 服务执行 -&gt; 序列化结果 -&gt; 网络传输 -&gt; 客户端存根 -&gt; 反序列化 -&gt; 客户端</code></pre>
<h3 id="🎯-设计目标"><a class="header-anchor" href="#🎯-设计目标"></a>🎯 设计目标</h3>
<p>我们将实现一个简单但功能完整的RPC框架，具有以下特性：</p>
<ol>
<li>支持注册和调用服务方法</li>
<li>使用JSON作为序列化格式</li>
<li>基于TCP的网络传输</li>
<li>简单的错误处理</li>
<li>支持并发调用</li>
</ol>
<h3 id="🏗️-框架结构设计"><a class="header-anchor" href="#🏗️-框架结构设计"></a>🏗️ 框架结构设计</h3>
<p>我们的RPC框架将包含以下主要组件：</p>
<ol>
<li><strong>服务注册中心</strong>：管理可用的服务和方法</li>
<li><strong>服务端</strong>：注册服务并处理客户端请求</li>
<li><strong>客户端</strong>：发送请求并接收响应</li>
<li><strong>编解码器</strong>：负责请求和响应的序列化/反序列化</li>
<li><strong>传输层</strong>：处理网络通信</li>
</ol>
<h3 id="💻-代码实现"><a class="header-anchor" href="#💻-代码实现"></a>💻 代码实现</h3>
<p>让我们开始实现这个简单的RPC框架，我们将其命名为&quot;SimpleRPC&quot;。</p>
<h4 id="1-定义消息结构"><a class="header-anchor" href="#1-定义消息结构"></a>1. 定义消息结构</h4>
<p>首先，我们需要定义RPC请求和响应的消息结构：</p>
<pre><code class="hljs go"><span class="hljs-keyword">package</span> simplerpc

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;encoding/json&quot;</span>
	<span class="hljs-string">&quot;errors&quot;</span>
	<span class="hljs-string">&quot;fmt&quot;</span>
	<span class="hljs-string">&quot;io&quot;</span>
	<span class="hljs-string">&quot;log&quot;</span>
	<span class="hljs-string">&quot;net&quot;</span>
	<span class="hljs-string">&quot;reflect&quot;</span>
	<span class="hljs-string">&quot;strings&quot;</span>
	<span class="hljs-string">&quot;sync&quot;</span>
	<span class="hljs-string">&quot;unicode&quot;</span>
)

<span class="hljs-comment">// 请求结构</span>
<span class="hljs-keyword">type</span> Request <span class="hljs-keyword">struct</span> &#123;
	ServiceMethod <span class="hljs-keyword">string</span>        <span class="hljs-string">`json:&quot;service_method&quot;`</span> <span class="hljs-comment">// 格式: &quot;Service.Method&quot;</span>
	Args          <span class="hljs-keyword">interface</span>&#123;&#125;   <span class="hljs-string">`json:&quot;args&quot;`</span>           <span class="hljs-comment">// 参数</span>
	ReqID         <span class="hljs-keyword">uint64</span>        <span class="hljs-string">`json:&quot;req_id&quot;`</span>         <span class="hljs-comment">// 请求ID</span>
&#125;

<span class="hljs-comment">// 响应结构</span>
<span class="hljs-keyword">type</span> Response <span class="hljs-keyword">struct</span> &#123;
	ServiceMethod <span class="hljs-keyword">string</span>      <span class="hljs-string">`json:&quot;service_method&quot;`</span> <span class="hljs-comment">// 对应请求的ServiceMethod</span>
	ReqID         <span class="hljs-keyword">uint64</span>      <span class="hljs-string">`json:&quot;req_id&quot;`</span>         <span class="hljs-comment">// 对应请求的ID</span>
	Error         <span class="hljs-keyword">string</span>      <span class="hljs-string">`json:&quot;error&quot;`</span>          <span class="hljs-comment">// 错误信息，如果调用成功则为空</span>
	Result        <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-string">`json:&quot;result&quot;`</span>         <span class="hljs-comment">// 调用结果</span>
&#125;</code></pre>
<h4 id="2-实现编解码器"><a class="header-anchor" href="#2-实现编解码器"></a>2. 实现编解码器</h4>
<p>接下来，我们实现一个简单的JSON编解码器：</p>
<pre><code class="hljs go"><span class="hljs-comment">// 编解码器接口</span>
<span class="hljs-keyword">type</span> Codec <span class="hljs-keyword">interface</span> &#123;
	ReadRequest() (*Request, error)
	ReadResponse() (*Response, error)
	WriteRequest(*Request) error
	WriteResponse(*Response) error
	Close() error
&#125;

<span class="hljs-comment">// JSON编解码器</span>
<span class="hljs-keyword">type</span> JSONCodec <span class="hljs-keyword">struct</span> &#123;
	conn io.ReadWriteCloser
	dec  *json.Decoder
	enc  *json.Encoder
	mu   sync.Mutex
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewJSONCodec</span><span class="hljs-params">(conn io.ReadWriteCloser)</span> *<span class="hljs-title">JSONCodec</span></span> &#123;
	<span class="hljs-keyword">return</span> &amp;JSONCodec&#123;
		conn: conn,
		dec:  json.NewDecoder(conn),
		enc:  json.NewEncoder(conn),
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *JSONCodec)</span> <span class="hljs-title">ReadRequest</span><span class="hljs-params">()</span> <span class="hljs-params">(*Request, error)</span></span> &#123;
	<span class="hljs-keyword">var</span> req Request
	<span class="hljs-keyword">if</span> err := c.dec.Decode(&amp;req); err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
	&#125;
	<span class="hljs-keyword">return</span> &amp;req, <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *JSONCodec)</span> <span class="hljs-title">ReadResponse</span><span class="hljs-params">()</span> <span class="hljs-params">(*Response, error)</span></span> &#123;
	<span class="hljs-keyword">var</span> resp Response
	<span class="hljs-keyword">if</span> err := c.dec.Decode(&amp;resp); err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
	&#125;
	<span class="hljs-keyword">return</span> &amp;resp, <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *JSONCodec)</span> <span class="hljs-title">WriteRequest</span><span class="hljs-params">(req *Request)</span> <span class="hljs-title">error</span></span> &#123;
	c.mu.Lock()
	<span class="hljs-keyword">defer</span> c.mu.Unlock()
	<span class="hljs-keyword">return</span> c.enc.Encode(req)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *JSONCodec)</span> <span class="hljs-title">WriteResponse</span><span class="hljs-params">(resp *Response)</span> <span class="hljs-title">error</span></span> &#123;
	c.mu.Lock()
	<span class="hljs-keyword">defer</span> c.mu.Unlock()
	<span class="hljs-keyword">return</span> c.enc.Encode(resp)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *JSONCodec)</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;
	<span class="hljs-keyword">return</span> c.conn.Close()
&#125;</code></pre>
<h4 id="3-服务注册与方法调用"><a class="header-anchor" href="#3-服务注册与方法调用"></a>3. 服务注册与方法调用</h4>
<p>现在，我们需要实现服务注册和方法调用的核心逻辑：</p>
<pre><code class="hljs go"><span class="hljs-comment">// 服务类型</span>
<span class="hljs-keyword">type</span> Service <span class="hljs-keyword">struct</span> &#123;
	name   <span class="hljs-keyword">string</span>                 <span class="hljs-comment">// 服务名称</span>
	rcvr   reflect.Value          <span class="hljs-comment">// 接收者对象</span>
	typ    reflect.Type           <span class="hljs-comment">// 接收者类型</span>
	method <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*MethodType <span class="hljs-comment">// 方法集合</span>
&#125;

<span class="hljs-comment">// 方法类型</span>
<span class="hljs-keyword">type</span> MethodType <span class="hljs-keyword">struct</span> &#123;
	method    reflect.Method <span class="hljs-comment">// 方法本身</span>
	ArgType   reflect.Type   <span class="hljs-comment">// 第一个参数类型</span>
	ReplyType reflect.Type   <span class="hljs-comment">// 第二个参数类型</span>
&#125;

<span class="hljs-comment">// 服务注册中心</span>
<span class="hljs-keyword">type</span> Registry <span class="hljs-keyword">struct</span> &#123;
	mu       sync.RWMutex
	services <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*Service
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRegistry</span><span class="hljs-params">()</span> *<span class="hljs-title">Registry</span></span> &#123;
	<span class="hljs-keyword">return</span> &amp;Registry&#123;
		services: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*Service),
	&#125;
&#125;

<span class="hljs-comment">// 注册服务</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Registry)</span> <span class="hljs-title">Register</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;
	s := <span class="hljs-built_in">new</span>(Service)
	s.rcvr = reflect.ValueOf(rcvr)
	s.typ = reflect.TypeOf(rcvr)
	s.name = reflect.Indirect(s.rcvr).Type().Name()
	<span class="hljs-keyword">if</span> s.name == <span class="hljs-string">&quot;&quot;</span> &#123;
		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;无法获取服务名称&quot;</span>)
	&#125;
	
	s.method = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*MethodType)
	
	<span class="hljs-comment">// 遍历方法并注册</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; s.typ.NumMethod(); i++ &#123;
		method := s.typ.Method(i)
		mtype := method.Type
		
		<span class="hljs-comment">// 方法必须是导出的</span>
		<span class="hljs-keyword">if</span> method.PkgPath != <span class="hljs-string">&quot;&quot;</span> &#123;
			<span class="hljs-keyword">continue</span>
		&#125;
		
		<span class="hljs-comment">// 方法必须有三个参数: receiver, args, *reply</span>
		<span class="hljs-keyword">if</span> mtype.NumIn() != <span class="hljs-number">3</span> &#123;
			<span class="hljs-keyword">continue</span>
		&#125;
		
		<span class="hljs-comment">// 第二个参数必须是导出的或内建类型</span>
		argType := mtype.In(<span class="hljs-number">1</span>)
		<span class="hljs-keyword">if</span> !isExportedOrBuiltin(argType) &#123;
			<span class="hljs-keyword">continue</span>
		&#125;
		
		<span class="hljs-comment">// 第三个参数必须是指针类型</span>
		replyType := mtype.In(<span class="hljs-number">2</span>)
		<span class="hljs-keyword">if</span> replyType.Kind() != reflect.Ptr &#123;
			<span class="hljs-keyword">continue</span>
		&#125;
		
		<span class="hljs-comment">// 方法必须返回一个error</span>
		<span class="hljs-keyword">if</span> mtype.NumOut() != <span class="hljs-number">1</span> &#123;
			<span class="hljs-keyword">continue</span>
		&#125;
		<span class="hljs-keyword">if</span> returnType := mtype.Out(<span class="hljs-number">0</span>); returnType != reflect.TypeOf((*error)(<span class="hljs-literal">nil</span>)).Elem() &#123;
			<span class="hljs-keyword">continue</span>
		&#125;
		
		s.method[method.Name] = &amp;MethodType&#123;
			method:    method,
			ArgType:   argType,
			ReplyType: replyType,
		&#125;
	&#125;
	
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s.method) == <span class="hljs-number">0</span> &#123;
		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;服务没有可用的RPC方法&quot;</span>)
	&#125;
	
	r.mu.Lock()
	<span class="hljs-keyword">defer</span> r.mu.Unlock()
	r.services[s.name] = s
	
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-comment">// 查找服务方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Registry)</span> <span class="hljs-title">findMethod</span><span class="hljs-params">(serviceMethod <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(svc *Service, mtype *MethodType, err error)</span></span> &#123;
	r.mu.RLock()
	<span class="hljs-keyword">defer</span> r.mu.RUnlock()
	
	<span class="hljs-comment">// 解析服务和方法名</span>
	parts := strings.Split(serviceMethod, <span class="hljs-string">&quot;.&quot;</span>)
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) != <span class="hljs-number">2</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;服务方法格式错误，应为 &#x27;Service.Method&#x27;&quot;</span>)
	&#125;
	
	serviceName, methodName := parts[<span class="hljs-number">0</span>], parts[<span class="hljs-number">1</span>]
	
	<span class="hljs-comment">// 查找服务</span>
	service, ok := r.services[serviceName]
	<span class="hljs-keyword">if</span> !ok &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;服务 %s 不存在&quot;</span>, serviceName)
	&#125;
	
	<span class="hljs-comment">// 查找方法</span>
	method, ok := service.method[methodName]
	<span class="hljs-keyword">if</span> !ok &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;方法 %s 在服务 %s 中不存在&quot;</span>, methodName, serviceName)
	&#125;
	
	<span class="hljs-keyword">return</span> service, method, <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-comment">// 调用服务方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Registry)</span> <span class="hljs-title">call</span><span class="hljs-params">(serviceMethod <span class="hljs-keyword">string</span>, args <span class="hljs-keyword">interface</span>&#123;&#125;, reply <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;
	service, mtype, err := r.findMethod(serviceMethod)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> err
	&#125;
	
	<span class="hljs-comment">// 将参数转换为正确的类型</span>
	argValue := reflect.ValueOf(args)
	<span class="hljs-keyword">if</span> argValue.Type() != mtype.ArgType &#123;
		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;参数类型不匹配: %v vs %v&quot;</span>, argValue.Type(), mtype.ArgType)
	&#125;
	
	replyValue := reflect.ValueOf(reply)
	<span class="hljs-keyword">if</span> replyValue.Type() != mtype.ReplyType &#123;
		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;回复类型不匹配: %v vs %v&quot;</span>, replyValue.Type(), mtype.ReplyType)
	&#125;
	
	<span class="hljs-comment">// 调用方法</span>
	function := mtype.method.Func
	returnValues := function.Call([]reflect.Value&#123;
		service.rcvr,
		argValue,
		replyValue,
	&#125;)
	
	<span class="hljs-comment">// 处理错误</span>
	errInter := returnValues[<span class="hljs-number">0</span>].Interface()
	<span class="hljs-keyword">if</span> errInter != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> errInter.(error)
	&#125;
	
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-comment">// 判断类型是否为导出或内建类型</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isExportedOrBuiltin</span><span class="hljs-params">(t reflect.Type)</span> <span class="hljs-title">bool</span></span> &#123;
	<span class="hljs-keyword">if</span> t.Kind() == reflect.Ptr &#123;
		t = t.Elem()
	&#125;
	
	<span class="hljs-comment">// 内建类型</span>
	<span class="hljs-keyword">if</span> t.PkgPath() == <span class="hljs-string">&quot;&quot;</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
	&#125;
	
	<span class="hljs-comment">// 导出类型</span>
	<span class="hljs-keyword">return</span> t.Name() != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; unicode.IsUpper(<span class="hljs-keyword">rune</span>(t.Name()[<span class="hljs-number">0</span>]))
&#125;</code></pre>
<h4 id="4-实现服务端"><a class="header-anchor" href="#4-实现服务端"></a>4. 实现服务端</h4>
<p>接下来，我们实现RPC服务端：</p>
<pre><code class="hljs go"><span class="hljs-comment">// 服务端</span>
<span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;
	registry *Registry
	mu       sync.Mutex
	seq      <span class="hljs-keyword">uint64</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">()</span> *<span class="hljs-title">Server</span></span> &#123;
	<span class="hljs-keyword">return</span> &amp;Server&#123;
		registry: NewRegistry(),
	&#125;
&#125;

<span class="hljs-comment">// 注册服务</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span> <span class="hljs-title">Register</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;
	<span class="hljs-keyword">return</span> s.registry.Register(rcvr)
&#125;

<span class="hljs-comment">// 启动服务监听</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span> <span class="hljs-title">Listen</span><span class="hljs-params">(network, address <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;
	listener, err := net.Listen(network, address)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> err
	&#125;
	<span class="hljs-keyword">defer</span> listener.Close()
	
	log.Printf(<span class="hljs-string">&quot;RPC服务器监听在 %s\n&quot;</span>, address)
	
	<span class="hljs-keyword">for</span> &#123;
		conn, err := listener.Accept()
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
			log.Printf(<span class="hljs-string">&quot;接受连接错误: %v\n&quot;</span>, err)
			<span class="hljs-keyword">continue</span>
		&#125;
		
		<span class="hljs-keyword">go</span> s.handleConnection(conn)
	&#125;
&#125;

<span class="hljs-comment">// 处理连接</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span> <span class="hljs-title">handleConnection</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;
	<span class="hljs-keyword">defer</span> conn.Close()
	
	codec := NewJSONCodec(conn)
	<span class="hljs-keyword">defer</span> codec.Close()
	
	<span class="hljs-keyword">for</span> &#123;
		req, err := codec.ReadRequest()
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
			<span class="hljs-keyword">if</span> err != io.EOF &#123;
				log.Printf(<span class="hljs-string">&quot;读取请求错误: %v\n&quot;</span>, err)
			&#125;
			<span class="hljs-keyword">break</span>
		&#125;
		
		<span class="hljs-keyword">go</span> s.handleRequest(codec, req)
	&#125;
&#125;

<span class="hljs-comment">// 处理请求</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(codec *JSONCodec, req *Request)</span></span> &#123;
	resp := &amp;Response&#123;
		ServiceMethod: req.ServiceMethod,
		ReqID:         req.ReqID,
	&#125;
	
	<span class="hljs-comment">// 创建参数和回复值</span>
	service, mtype, err := s.registry.findMethod(req.ServiceMethod)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		resp.Error = err.Error()
		codec.WriteResponse(resp)
		<span class="hljs-keyword">return</span>
	&#125;
	
	<span class="hljs-comment">// 创建参数实例</span>
	argv := reflect.New(mtype.ArgType)
	
	<span class="hljs-comment">// 将请求参数解码到argv</span>
	<span class="hljs-keyword">if</span> req.Args != <span class="hljs-literal">nil</span> &#123;
		argBytes, err := json.Marshal(req.Args)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
			resp.Error = fmt.Sprintf(<span class="hljs-string">&quot;参数编码错误: %v&quot;</span>, err)
			codec.WriteResponse(resp)
			<span class="hljs-keyword">return</span>
		&#125;
		
		<span class="hljs-keyword">if</span> err := json.Unmarshal(argBytes, argv.Interface()); err != <span class="hljs-literal">nil</span> &#123;
			resp.Error = fmt.Sprintf(<span class="hljs-string">&quot;参数解码错误: %v&quot;</span>, err)
			codec.WriteResponse(resp)
			<span class="hljs-keyword">return</span>
		&#125;
	&#125;
	
	<span class="hljs-comment">// 创建回复实例</span>
	replyv := reflect.New(mtype.ReplyType.Elem())
	
	<span class="hljs-comment">// 调用服务方法</span>
	function := mtype.method.Func
	returnValues := function.Call([]reflect.Value&#123;
		service.rcvr,
		argv.Elem(),
		replyv,
	&#125;)
	
	<span class="hljs-comment">// 处理错误</span>
	errInter := returnValues[<span class="hljs-number">0</span>].Interface()
	<span class="hljs-keyword">if</span> errInter != <span class="hljs-literal">nil</span> &#123;
		resp.Error = errInter.(error).Error()
	&#125; <span class="hljs-keyword">else</span> &#123;
		resp.Result = replyv.Interface()
	&#125;
	
	<span class="hljs-comment">// 发送响应</span>
	<span class="hljs-keyword">if</span> err := codec.WriteResponse(resp); err != <span class="hljs-literal">nil</span> &#123;
		log.Printf(<span class="hljs-string">&quot;写入响应错误: %v\n&quot;</span>, err)
	&#125;
&#125;</code></pre>
<h4 id="5-实现客户端"><a class="header-anchor" href="#5-实现客户端"></a>5. 实现客户端</h4>
<p>最后，我们实现RPC客户端：</p>
<pre><code class="hljs go"><span class="hljs-comment">// 客户端</span>
<span class="hljs-keyword">type</span> Client <span class="hljs-keyword">struct</span> &#123;
	codec  Codec
	mu     sync.Mutex
	seq    <span class="hljs-keyword">uint64</span>
	pending <span class="hljs-keyword">map</span>[<span class="hljs-keyword">uint64</span>]*Call
&#125;

<span class="hljs-comment">// 调用结构</span>
<span class="hljs-keyword">type</span> Call <span class="hljs-keyword">struct</span> &#123;
	ServiceMethod <span class="hljs-keyword">string</span>      <span class="hljs-comment">// 格式: &quot;Service.Method&quot;</span>
	Args          <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 参数</span>
	Reply         <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 回复</span>
	Error         error       <span class="hljs-comment">// 错误</span>
	Done          <span class="hljs-keyword">chan</span> *Call  <span class="hljs-comment">// 调用完成时的信号</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(call *Call)</span> <span class="hljs-title">done</span><span class="hljs-params">()</span></span> &#123;
	call.Done &lt;- call
&#125;

<span class="hljs-comment">// 创建新客户端</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClient</span><span class="hljs-params">(conn io.ReadWriteCloser)</span> *<span class="hljs-title">Client</span></span> &#123;
	client := &amp;Client&#123;
		codec:   NewJSONCodec(conn),
		pending: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">uint64</span>]*Call),
	&#125;
	
	<span class="hljs-keyword">go</span> client.receiveResponse()
	
	<span class="hljs-keyword">return</span> client
&#125;

<span class="hljs-comment">// 连接到RPC服务器</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*Client, error)</span></span> &#123;
	conn, err := net.Dial(network, address)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
	&#125;
	
	<span class="hljs-keyword">return</span> NewClient(conn), <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-comment">// 接收响应</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span> <span class="hljs-title">receiveResponse</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">for</span> &#123;
		resp, err := c.codec.ReadResponse()
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
			<span class="hljs-keyword">if</span> err != io.EOF &#123;
				log.Printf(<span class="hljs-string">&quot;读取响应错误: %v\n&quot;</span>, err)
			&#125;
			<span class="hljs-keyword">break</span>
		&#125;
		
		c.mu.Lock()
		call, ok := c.pending[resp.ReqID]
		<span class="hljs-built_in">delete</span>(c.pending, resp.ReqID)
		c.mu.Unlock()
		
		<span class="hljs-keyword">if</span> !ok &#123;
			log.Printf(<span class="hljs-string">&quot;找不到请求ID: %d\n&quot;</span>, resp.ReqID)
			<span class="hljs-keyword">continue</span>
		&#125;
		
		<span class="hljs-keyword">if</span> resp.Error != <span class="hljs-string">&quot;&quot;</span> &#123;
			call.Error = errors.New(resp.Error)
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> resp.Result != <span class="hljs-literal">nil</span> &#123;
			<span class="hljs-comment">// 将结果解码到reply</span>
			resultBytes, err := json.Marshal(resp.Result)
			<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
				call.Error = fmt.Errorf(<span class="hljs-string">&quot;结果编码错误: %v&quot;</span>, err)
			&#125; <span class="hljs-keyword">else</span> &#123;
				<span class="hljs-keyword">if</span> err := json.Unmarshal(resultBytes, call.Reply); err != <span class="hljs-literal">nil</span> &#123;
					call.Error = fmt.Errorf(<span class="hljs-string">&quot;结果解码错误: %v&quot;</span>, err)
				&#125;
			&#125;
		&#125;
		
		call.done()
	&#125;
	
	<span class="hljs-comment">// 关闭连接时，将所有挂起的调用标记为失败</span>
	c.mu.Lock()
	<span class="hljs-keyword">for</span> _, call := <span class="hljs-keyword">range</span> c.pending &#123;
		call.Error = errors.New(<span class="hljs-string">&quot;连接已关闭&quot;</span>)
		call.done()
	&#125;
	c.mu.Unlock()
&#125;

<span class="hljs-comment">// 发送请求</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span> <span class="hljs-title">send</span><span class="hljs-params">(call *Call)</span></span> &#123;
	c.mu.Lock()
	<span class="hljs-keyword">defer</span> c.mu.Unlock()
	
	<span class="hljs-comment">// 分配请求ID</span>
	c.seq++
	reqID := c.seq
	
	<span class="hljs-comment">// 注册调用</span>
	c.pending[reqID] = call
	
	<span class="hljs-comment">// 创建并发送请求</span>
	req := &amp;Request&#123;
		ServiceMethod: call.ServiceMethod,
		Args:          call.Args,
		ReqID:         reqID,
	&#125;
	
	<span class="hljs-keyword">if</span> err := c.codec.WriteRequest(req); err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-built_in">delete</span>(c.pending, reqID)
		call.Error = err
		call.done()
	&#125;
&#125;

<span class="hljs-comment">// 调用服务方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span> <span class="hljs-title">Call</span><span class="hljs-params">(serviceMethod <span class="hljs-keyword">string</span>, args <span class="hljs-keyword">interface</span>&#123;&#125;, reply <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;
	call := &amp;Call&#123;
		ServiceMethod: serviceMethod,
		Args:          args,
		Reply:         reply,
		Done:          <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>),
	&#125;
	
	c.send(call)
	
	<span class="hljs-comment">// 等待调用完成</span>
	&lt;-call.Done
	
	<span class="hljs-keyword">return</span> call.Error
&#125;

<span class="hljs-comment">// 异步调用服务方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span> <span class="hljs-title">Go</span><span class="hljs-params">(serviceMethod <span class="hljs-keyword">string</span>, args <span class="hljs-keyword">interface</span>&#123;&#125;, reply <span class="hljs-keyword">interface</span>&#123;&#125;)</span> *<span class="hljs-title">Call</span></span> &#123;
	call := &amp;Call&#123;
		ServiceMethod: serviceMethod,
		Args:          args,
		Reply:         reply,
		Done:          <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>),
	&#125;
	
	c.send(call)
	
	<span class="hljs-keyword">return</span> call
&#125;

<span class="hljs-comment">// 关闭客户端</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;
	<span class="hljs-keyword">return</span> c.codec.Close()
&#125;</code></pre>
<h3 id="🧪-使用示例"><a class="header-anchor" href="#🧪-使用示例"></a>🧪 使用示例</h3>
<p>现在我们已经实现了一个简单的RPC框架，让我们来看看如何使用它：</p>
<pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;fmt&quot;</span>
	<span class="hljs-string">&quot;log&quot;</span>
	<span class="hljs-string">&quot;simplerpc&quot;</span>
	<span class="hljs-string">&quot;time&quot;</span>
)

<span class="hljs-comment">// 算术服务</span>
<span class="hljs-keyword">type</span> Arith <span class="hljs-keyword">struct</span>&#123;&#125;

<span class="hljs-comment">// 乘法方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Arith)</span> <span class="hljs-title">Multiply</span><span class="hljs-params">(args Args, reply *<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;
	*reply = args.A * args.B
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-comment">// 除法方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Arith)</span> <span class="hljs-title">Divide</span><span class="hljs-params">(args Args, reply *Quotient)</span> <span class="hljs-title">error</span></span> &#123;
	<span class="hljs-keyword">if</span> args.B == <span class="hljs-number">0</span> &#123;
		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;除数不能为零&quot;</span>)
	&#125;
	reply.Quo = args.A / args.B
	reply.Rem = args.A % args.B
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-comment">// 参数结构</span>
<span class="hljs-keyword">type</span> Args <span class="hljs-keyword">struct</span> &#123;
	A, B <span class="hljs-keyword">int</span>
&#125;

<span class="hljs-comment">// 商和余数</span>
<span class="hljs-keyword">type</span> Quotient <span class="hljs-keyword">struct</span> &#123;
	Quo, Rem <span class="hljs-keyword">int</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">// 启动服务器</span>
	<span class="hljs-keyword">go</span> startServer()
	
	<span class="hljs-comment">// 等待服务器启动</span>
	time.Sleep(<span class="hljs-number">1</span> * time.Second)
	
	<span class="hljs-comment">// 创建客户端</span>
	client, err := simplerpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:1234&quot;</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		log.Fatal(<span class="hljs-string">&quot;连接服务器失败:&quot;</span>, err)
	&#125;
	<span class="hljs-keyword">defer</span> client.Close()
	
	<span class="hljs-comment">// 同步调用</span>
	args := &amp;Args&#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;
	<span class="hljs-keyword">var</span> reply <span class="hljs-keyword">int</span>
	<span class="hljs-keyword">if</span> err := client.Call(<span class="hljs-string">&quot;Arith.Multiply&quot;</span>, args, &amp;reply); err != <span class="hljs-literal">nil</span> &#123;
		log.Fatal(<span class="hljs-string">&quot;调用Arith.Multiply失败:&quot;</span>, err)
	&#125;
	fmt.Printf(<span class="hljs-string">&quot;Arith.Multiply: %d * %d = %d\n&quot;</span>, args.A, args.B, reply)
	
	<span class="hljs-comment">// 异步调用</span>
	quotient := <span class="hljs-built_in">new</span>(Quotient)
	divCall := client.Go(<span class="hljs-string">&quot;Arith.Divide&quot;</span>, &amp;Args&#123;<span class="hljs-number">15</span>, <span class="hljs-number">5</span>&#125;, quotient)
	
	<span class="hljs-comment">// 做其他事情...</span>
	
	<span class="hljs-comment">// 等待调用完成</span>
	&lt;-divCall.Done
	<span class="hljs-keyword">if</span> divCall.Error != <span class="hljs-literal">nil</span> &#123;
		log.Fatal(<span class="hljs-string">&quot;调用Arith.Divide失败:&quot;</span>, divCall.Error)
	&#125;
	fmt.Printf(<span class="hljs-string">&quot;Arith.Divide: %d / %d = %d 余 %d\n&quot;</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, quotient.Quo, quotient.Rem)
	
	<span class="hljs-comment">// 测试错误处理</span>
	<span class="hljs-keyword">if</span> err := client.Call(<span class="hljs-string">&quot;Arith.Divide&quot;</span>, &amp;Args&#123;<span class="hljs-number">10</span>, <span class="hljs-number">0</span>&#125;, quotient); err != <span class="hljs-literal">nil</span> &#123;
		fmt.Println(<span class="hljs-string">&quot;预期的错误:&quot;</span>, err)
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">()</span></span> &#123;
	server := simplerpc.NewServer()
	<span class="hljs-keyword">if</span> err := server.Register(<span class="hljs-built_in">new</span>(Arith)); err != <span class="hljs-literal">nil</span> &#123;
		log.Fatal(<span class="hljs-string">&quot;注册Arith服务失败:&quot;</span>, err)
	&#125;
	
	<span class="hljs-keyword">if</span> err := server.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:1234&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;
		log.Fatal(<span class="hljs-string">&quot;启动服务器失败:&quot;</span>, err)
	&#125;
&#125;</code></pre>
<h3 id="🔧-框架优化"><a class="header-anchor" href="#🔧-框架优化"></a>🔧 框架优化</h3>
<p>我们的RPC框架虽然简单，但仍有很多可以优化的地方：</p>
<h4 id="1-支持多种编解码格式"><a class="header-anchor" href="#1-支持多种编解码格式"></a>1. 支持多种编解码格式</h4>
<p>我们可以扩展框架，支持更多的编解码格式，如Protocol Buffers、MessagePack等：</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> CodecType <span class="hljs-keyword">string</span>

<span class="hljs-keyword">const</span> (
	JSONCodecType   CodecType = <span class="hljs-string">&quot;json&quot;</span>
	ProtoCodecType  CodecType = <span class="hljs-string">&quot;proto&quot;</span>
	MsgPackCodecType CodecType = <span class="hljs-string">&quot;msgpack&quot;</span>
)

<span class="hljs-comment">// 编解码器工厂</span>
<span class="hljs-keyword">type</span> CodecFactory <span class="hljs-keyword">interface</span> &#123;
	NewCodec(conn io.ReadWriteCloser) Codec
&#125;

<span class="hljs-comment">// 注册编解码器工厂</span>
<span class="hljs-keyword">var</span> codecFactories = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[CodecType]CodecFactory)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterCodecFactory</span><span class="hljs-params">(typ CodecType, factory CodecFactory)</span></span> &#123;
	codecFactories[typ] = factory
&#125;</code></pre>
<h4 id="2-添加超时控制"><a class="header-anchor" href="#2-添加超时控制"></a>2. 添加超时控制</h4>
<p>为了提高系统的可靠性，我们可以添加请求超时控制：</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span> <span class="hljs-title">CallWithTimeout</span><span class="hljs-params">(serviceMethod <span class="hljs-keyword">string</span>, args <span class="hljs-keyword">interface</span>&#123;&#125;, reply <span class="hljs-keyword">interface</span>&#123;&#125;, timeout time.Duration)</span> <span class="hljs-title">error</span></span> &#123;
	call := &amp;Call&#123;
		ServiceMethod: serviceMethod,
		Args:          args,
		Reply:         reply,
		Done:          <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>),
	&#125;
	
	c.send(call)
	
	<span class="hljs-keyword">select</span> &#123;
	<span class="hljs-keyword">case</span> &lt;-call.Done:
		<span class="hljs-keyword">return</span> call.Error
	<span class="hljs-keyword">case</span> &lt;-time.After(timeout):
		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;调用超时: %s&quot;</span>, serviceMethod)
	&#125;
&#125;</code></pre>
<h4 id="3-添加连接池"><a class="header-anchor" href="#3-添加连接池"></a>3. 添加连接池</h4>
<p>对于高并发场景，我们可以实现一个连接池来复用连接：</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> ClientPool <span class="hljs-keyword">struct</span> &#123;
	mu      sync.Mutex
	clients []*Client
	addr    <span class="hljs-keyword">string</span>
	network <span class="hljs-keyword">string</span>
	size    <span class="hljs-keyword">int</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClientPool</span><span class="hljs-params">(network, addr <span class="hljs-keyword">string</span>, size <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*ClientPool, error)</span></span> &#123;
	pool := &amp;ClientPool&#123;
		network: network,
		addr:    addr,
		size:    size,
	&#125;
	
	<span class="hljs-comment">// 预创建连接</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;
		client, err := Dial(network, addr)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
		&#125;
		pool.clients = <span class="hljs-built_in">append</span>(pool.clients, client)
	&#125;
	
	<span class="hljs-keyword">return</span> pool, <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *ClientPool)</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span> <span class="hljs-params">(*Client, error)</span></span> &#123;
	p.mu.Lock()
	<span class="hljs-keyword">defer</span> p.mu.Unlock()
	
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p.clients) == <span class="hljs-number">0</span> &#123;
		<span class="hljs-keyword">return</span> Dial(p.network, p.addr)
	&#125;
	
	<span class="hljs-comment">// 取出最后一个客户端</span>
	client := p.clients[<span class="hljs-built_in">len</span>(p.clients)<span class="hljs-number">-1</span>]
	p.clients = p.clients[:<span class="hljs-built_in">len</span>(p.clients)<span class="hljs-number">-1</span>]
	
	<span class="hljs-keyword">return</span> client, <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *ClientPool)</span> <span class="hljs-title">Put</span><span class="hljs-params">(client *Client)</span></span> &#123;
	p.mu.Lock()
	<span class="hljs-keyword">defer</span> p.mu.Unlock()
	
	<span class="hljs-comment">// 如果池已满，关闭客户端</span>
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p.clients) &gt;= p.size &#123;
		client.Close()
		<span class="hljs-keyword">return</span>
	&#125;
	
	p.clients = <span class="hljs-built_in">append</span>(p.clients, client)
&#125;</code></pre>
<h4 id="4-服务发现与负载均衡"><a class="header-anchor" href="#4-服务发现与负载均衡"></a>4. 服务发现与负载均衡</h4>
<p>在实际的分布式系统中，我们需要服务发现和负载均衡机制：</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> ServiceDiscovery <span class="hljs-keyword">interface</span> &#123;
	GetService(name <span class="hljs-keyword">string</span>) ([]<span class="hljs-keyword">string</span>, error) <span class="hljs-comment">// 返回服务地址列表</span>
	Register(name, addr <span class="hljs-keyword">string</span>) error         <span class="hljs-comment">// 注册服务</span>
	Deregister(name, addr <span class="hljs-keyword">string</span>) error       <span class="hljs-comment">// 注销服务</span>
&#125;

<span class="hljs-keyword">type</span> LoadBalancer <span class="hljs-keyword">interface</span> &#123;
	Select(servers []<span class="hljs-keyword">string</span>) <span class="hljs-keyword">string</span> <span class="hljs-comment">// 选择一个服务器</span>
&#125;

<span class="hljs-comment">// 简单的轮询负载均衡器</span>
<span class="hljs-keyword">type</span> RoundRobinBalancer <span class="hljs-keyword">struct</span> &#123;
	mu    sync.Mutex
	index <span class="hljs-keyword">int</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *RoundRobinBalancer)</span> <span class="hljs-title">Select</span><span class="hljs-params">(servers []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(servers) == <span class="hljs-number">0</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>
	&#125;
	
	b.mu.Lock()
	<span class="hljs-keyword">defer</span> b.mu.Unlock()
	
	server := servers[b.index]
	b.index = (b.index + <span class="hljs-number">1</span>) % <span class="hljs-built_in">len</span>(servers)
	
	<span class="hljs-keyword">return</span> server
&#125;</code></pre>
<h3 id="📝-总结"><a class="header-anchor" href="#📝-总结"></a>📝 总结</h3>
<p>在本文中，我们从零开始实现了一个简单但功能完整的RPC框架，包括：</p>
<ol>
<li><strong>消息结构设计</strong>：定义了RPC请求和响应的格式</li>
<li><strong>编解码器</strong>：实现了基于JSON的序列化和反序列化</li>
<li><strong>服务注册</strong>：支持注册服务和方法</li>
<li><strong>服务调用</strong>：通过反射机制调用服务方法</li>
<li><strong>网络传输</strong>：基于TCP的客户端和服务端实现</li>
<li><strong>错误处理</strong>：在各个环节处理可能的错误</li>
<li><strong>并发支持</strong>：支持并发调用和处理</li>
</ol>
<p>这个简单的RPC框架展示了RPC的基本工作原理，虽然它与生产级的RPC框架（如gRPC、Thrift等）相比还有很大差距，但它包含了RPC的核心概念和实现细节。通过理解这个简单的实现，你可以更好地理解和使用复杂的RPC框架。</p>
<p>在实际项目中，除非有特殊需求，建议使用成熟的RPC框架，如Go标准库的<code>net/rpc</code>、<code>net/rpc/jsonrpc</code>，或者第三方框架如gRPC、Thrift等。这些框架经过了广泛的测试和优化，提供了更多的功能和更好的性能。</p>
<p>不过，通过自己实现一个RPC框架，你可以深入理解分布式系统的通信机制，这对于设计和优化分布式系统非常有帮助。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Golang/">Golang</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/golang/">golang</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
                    
                      <a class="hover-with-bg" href="/tags/RPC/">RPC</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2024/05/05/golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3sync%E5%8C%85%E7%9A%84%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">golang 深入理解sync包的并发原语</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2024/04/02/golang-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/">
                        <span class="hidden-mobile">golang 函数式编程实践</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      function loadDisqus() {
        var disqus_config = function () {
          this.page.url = 'https://blog.bopop.sbs/2024/04/15/golang-实现一个简单的RPC框架/';
          this.page.identifier = '/2024/04/15/golang-实现一个简单的RPC框架/';
        };
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + '' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      createObserver(loadDisqus, 'disqus_thread');
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="nofollow noopener noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  
    <div class="col-lg-7 mx-auto nopadding-md">
      <div class="container custom mx-auto">
        <img src="/img/Bopop-logo.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:220px; height:150px;">
      </div>
    </div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <!-- <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a> -->
        <span>© Bopop</span>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
